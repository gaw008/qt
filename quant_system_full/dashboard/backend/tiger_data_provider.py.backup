#!/usr/bin/env python3
"""
Tiger API Data Provider
Provides real Tiger API data integration for the enhanced FastAPI backend
"""

import os
import sys
import logging
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from decimal import Decimal

# Add bot directory to path for imports
BOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'bot'))
sys.path.append(BOT_DIR)

try:
    from tradeup_client import build_clients
    from execution_tiger import create_tiger_execution_engine
    from data import fetch_stock_data
    from market_state_machine import MarketStateMachine
    from intelligent_alert_system import IntelligentAlertSystem
    TIGER_AVAILABLE = True
    print("[TIGER_PROVIDER] Tiger API modules imported successfully")
except ImportError as e:
    print(f"[TIGER_PROVIDER] Warning: Tiger API modules not available: {e}")
    TIGER_AVAILABLE = False

# Add improvement directory to path for cost analysis
IMPROVEMENT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'improvement'))
sys.path.append(IMPROVEMENT_DIR)

# Try to import cost analysis modules
try:
    from cost_models.tiger_cost_integration import TigerCostAnalyzer
    from cost_models.trading_cost_model import create_cost_model
    COST_ANALYSIS_AVAILABLE = True
    print("[TIGER_PROVIDER] Cost analysis modules imported successfully")
except ImportError as e:
    print(f"[TIGER_PROVIDER] Warning: Cost analysis modules not available: {e}")
    COST_ANALYSIS_AVAILABLE = False

# Add dashboard backend directory to path for AI modules
DASHBOARD_BACKEND_DIR = os.path.dirname(__file__)
sys.path.append(DASHBOARD_BACKEND_DIR)

# Try to import AI modules
try:
    from real_ai_training_manager import RealAITrainingManager
    from real_ai_recommendations import get_real_ai_recommendations
    AI_MODULES_AVAILABLE = True
    print("[TIGER_PROVIDER] AI modules imported successfully")
except ImportError as e:
    print(f"[TIGER_PROVIDER] Warning: AI modules not available: {e}")
    AI_MODULES_AVAILABLE = False

logger = logging.getLogger(__name__)


class TigerDataProvider:
    """
    Tiger API data provider for the enhanced backend
    Handles real Tiger API data fetching and formatting
    """

    def __init__(self):
        self.quote_client = None
        self.trade_client = None
        self.execution_engine = None
        self.market_state_machine = None
        self.alert_system = None
        self.cost_analyzer = None
        self.ai_training_manager = None
        self._initialized = False

    async def initialize(self):
        """Initialize Tiger API clients and components"""
        if not TIGER_AVAILABLE:
            logger.warning("Tiger API not available - using mock data")
            return False

        try:
            # Initialize Tiger API clients
            self.quote_client, self.trade_client = build_clients()

            if self.quote_client and self.trade_client:
                self.execution_engine = create_tiger_execution_engine(
                    self.quote_client, self.trade_client
                )
                logger.info("Tiger API clients initialized successfully")
            else:
                logger.warning("Tiger API clients not available - using simulation mode")
                return False

            # Initialize market state machine
            try:
                self.market_state_machine = MarketStateMachine()
                logger.info("Market state machine initialized")
            except Exception as e:
                logger.warning(f"Market state machine initialization failed: {e}")

            # Initialize alert system
            try:
                self.alert_system = IntelligentAlertSystem()
                logger.info("Alert system initialized")
            except Exception as e:
                logger.warning(f"Alert system initialization failed: {e}")

            # Initialize cost analyzer
            if COST_ANALYSIS_AVAILABLE:
                try:
                    self.cost_analyzer = TigerCostAnalyzer()
                    logger.info("Cost analyzer initialized")
                except Exception as e:
                    logger.warning(f"Cost analyzer initialization failed: {e}")

            self._initialized = True
            return True

        except Exception as e:
            logger.error(f"Failed to initialize Tiger API components: {e}")
            return False

    def is_available(self) -> bool:
        """Check if Tiger API is available and initialized"""
        return TIGER_AVAILABLE and self._initialized

    async def get_assets(self, limit: int = 50, offset: int = 0, asset_type: Optional[str] = None) -> List[Dict]:
        """Get market assets data from Tiger API"""
        if not self.is_available():
            return self._get_mock_assets(limit, offset, asset_type)

        try:
            # Use Tiger API to get real market data
            assets = []
            symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "NVDA", "META", "NFLX", "AMD", "CRM"]

            # For now, use a mix of real Tiger data structure with mock data
            # TODO: Replace with actual Tiger quote client calls
            for i, symbol in enumerate(symbols[offset:offset+limit]):
                # This would be replaced with actual Tiger API calls:
                # quote_data = self.quote_client.get_quote_data(symbol)

                assets.append({
                    "symbol": symbol,
                    "name": f"{symbol} Inc.",
                    "type": "stock",
                    "sector": "Technology",
                    "price": 150.0 + i * 10,
                    "change": 2.5 - i * 0.5,
                    "change_percent": (2.5 - i * 0.5) / (150.0 + i * 10) * 100,
                    "volume": 1000000 + i * 100000,
                    "market_cap": 1000000000000.0,
                    "last_update": datetime.now().isoformat()
                })

            return assets

        except Exception as e:
            logger.error(f"Failed to fetch assets from Tiger API: {e}")
            return self._get_mock_assets(limit, offset, asset_type)

    async def get_positions(self) -> List[Dict]:
        """Get current positions from Tiger API"""
        if not self.is_available():
            return self._get_mock_positions()

        try:
            # Use Tiger API to get real positions
            # positions = self.trade_client.get_positions()

            # For now, return mock data structured like Tiger API response
            positions = [
                {
                    "symbol": "AAPL",
                    "quantity": 100,
                    "avg_price": 150.0,
                    "current_price": 155.0,
                    "market_value": 15500.0,
                    "unrealized_pnl": 500.0,
                    "unrealized_pnl_percent": 3.33,
                    "entry_time": (datetime.now() - timedelta(days=5)).isoformat(),
                    "last_update": datetime.now().isoformat()
                },
                {
                    "symbol": "GOOGL",
                    "quantity": 50,
                    "avg_price": 2500.0,
                    "current_price": 2550.0,
                    "market_value": 127500.0,
                    "unrealized_pnl": 2500.0,
                    "unrealized_pnl_percent": 2.0,
                    "entry_time": (datetime.now() - timedelta(days=3)).isoformat(),
                    "last_update": datetime.now().isoformat()
                }
            ]

            return positions

        except Exception as e:
            logger.error(f"Failed to fetch positions from Tiger API: {e}")
            return self._get_mock_positions()

    async def get_portfolio_summary(self) -> Dict:
        """Get portfolio summary from Tiger API"""
        if not self.is_available():
            return self._get_mock_portfolio_summary()

        try:
            # Use Tiger API to get real portfolio data
            # account_info = self.trade_client.get_account_info()

            # For now, return mock data structured like Tiger API response
            portfolio = {
                "total_value": 250000.0,
                "total_pnl": 12500.0,
                "total_pnl_percent": 5.26,
                "daily_pnl": 1250.0,
                "daily_pnl_percent": 0.5,
                "positions_count": 5,
                "cash_balance": 50000.0,
                "buying_power": 100000.0,
                "margin_used": 0.0,
                "risk_metrics": {
                    "sharpe_ratio": 1.8,
                    "max_drawdown": -0.08,
                    "portfolio_beta": 1.2,
                    "volatility": 0.16
                }
            }

            return portfolio

        except Exception as e:
            logger.error(f"Failed to fetch portfolio summary from Tiger API: {e}")
            return self._get_mock_portfolio_summary()

    async def get_orders(self, status: Optional[str] = None, symbol: Optional[str] = None, limit: int = 50) -> List[Dict]:
        """Get orders from Tiger API"""
        if not self.is_available():
            return self._get_mock_orders(status, symbol, limit)

        try:
            # Use Tiger API to get real orders
            # orders = self.trade_client.get_orders(status=status, symbol=symbol, limit=limit)

            # For now, return mock data structured like Tiger API response
            orders = [
                {
                    "id": "ORDER_001",
                    "symbol": "AAPL",
                    "side": "buy",
                    "type": "market",
                    "quantity": 100,
                    "price": None,
                    "status": "filled",
                    "filled_quantity": 100,
                    "avg_fill_price": 155.0,
                    "created_at": (datetime.now() - timedelta(hours=2)).isoformat(),
                    "updated_at": (datetime.now() - timedelta(hours=2)).isoformat()
                },
                {
                    "id": "ORDER_002",
                    "symbol": "GOOGL",
                    "side": "buy",
                    "type": "limit",
                    "quantity": 50,
                    "price": 2540.0,
                    "status": "pending",
                    "filled_quantity": 0,
                    "avg_fill_price": None,
                    "created_at": (datetime.now() - timedelta(minutes=30)).isoformat(),
                    "updated_at": (datetime.now() - timedelta(minutes=30)).isoformat()
                }
            ]

            return orders

        except Exception as e:
            logger.error(f"Failed to fetch orders from Tiger API: {e}")
            return self._get_mock_orders(status, symbol, limit)

    async def create_order(self, order_request: Dict) -> Dict:
        """Create order via Tiger API with cost analysis optimization"""
        if not self.is_available():
            return self._create_mock_order_with_cost_analysis(order_request)

        try:
            # Perform cost analysis before order creation
            cost_analysis = None
            if self.cost_analyzer and COST_ANALYSIS_AVAILABLE:
                try:
                    cost_analysis = await self._analyze_order_cost(order_request)
                    logger.info(f"Cost analysis completed for {order_request['symbol']}: {cost_analysis.get('cost_basis_points', 'N/A')} bps")
                except Exception as e:
                    logger.warning(f"Cost analysis failed: {e}")

            # Use Tiger API to create real order
            if self.execution_engine:
                # Apply cost optimization recommendations
                optimized_order = order_request.copy()
                if cost_analysis and cost_analysis.get("recommended_order_type"):
                    optimized_order["type"] = cost_analysis["recommended_order_type"]
                    logger.info(f"Order type optimized from {order_request['type']} to {optimized_order['type']} based on cost analysis")

                # result = self.execution_engine.execute_order(
                #     symbol=optimized_order["symbol"],
                #     side=optimized_order["side"],
                #     quantity=optimized_order["quantity"],
                #     order_type=optimized_order["type"],
                #     price=optimized_order.get("price"),
                #     stop_price=optimized_order.get("stop_price")
                # )
                pass

            # Create order with cost analysis
            order = {
                "id": f"ORDER_{int(datetime.now().timestamp())}",
                "symbol": order_request["symbol"],
                "side": order_request["side"],
                "type": order_request["type"],
                "quantity": order_request["quantity"],
                "price": order_request.get("price"),
                "stop_price": order_request.get("stop_price"),
                "status": "pending",
                "filled_quantity": 0,
                "avg_fill_price": None,
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "cost_analysis": cost_analysis
            }

            return order

        except Exception as e:
            logger.error(f"Failed to create order via Tiger API: {e}")
            return self._create_mock_order_with_cost_analysis(order_request)

    async def _analyze_order_cost(self, order_request: Dict) -> Optional[Dict]:
        """Analyze order cost using TigerCostAnalyzer"""
        try:
            if not self.cost_analyzer:
                return None

            # Mock market data for cost analysis
            # In real implementation, this would fetch from Tiger API
            market_data = {
                "symbol": order_request["symbol"],
                "price": order_request.get("price", 150.0),
                "spread": 0.01,  # Mock spread
                "volume": 1000000,  # Mock volume
                "avg_daily_volume": 10000000,  # Mock ADV
                "volatility": 0.15,  # Mock volatility
                "market_cap": 1000000000.0  # Mock market cap
            }

            # Perform cost analysis
            # cost_result = self.cost_analyzer.analyze_order_cost(
            #     symbol=order_request["symbol"],
            #     side=order_request["side"],
            #     quantity=order_request["quantity"],
            #     order_type=order_request["type"],
            #     market_data=market_data
            # )

            # Mock cost analysis result for now
            cost_result = {
                "total_cost": order_request["quantity"] * market_data["price"] * 0.0015,  # 15 bps
                "cost_basis_points": 15.0,
                "recommended_order_type": "limit" if order_request["type"] == "market" and order_request["quantity"] > 500 else order_request["type"],
                "market_data": market_data,
                "cost_breakdown": {
                    "spread_cost": 10.0,
                    "market_impact": 3.0,
                    "timing_cost": 2.0
                }
            }

            return cost_result

        except Exception as e:
            logger.error(f"Failed to analyze order cost: {e}")
            return None

    async def get_market_state(self) -> Dict:
        """Get market state from market state machine"""
        try:
            if self.market_state_machine:
                state = self.market_state_machine.get_current_state()
                return {
                    "status": "open",
                    "market_trend": 0.02,
                    "volatility": 0.18,
                    "volume_ratio": 1.1,
                    "fear_greed_index": 65,
                    "next_open": (datetime.now() + timedelta(hours=16)).isoformat(),
                    "regime": state.get("current_state", "normal"),
                    "risk_level": "medium"
                }
            else:
                return self._get_mock_market_state()

        except Exception as e:
            logger.error(f"Failed to get market state: {e}")
            return self._get_mock_market_state()

    async def get_alerts(self, severity: Optional[str] = None, alert_type: Optional[str] = None, limit: int = 50) -> List[Dict]:
        """Get alerts from alert system"""
        try:
            if self.alert_system:
                # alerts = self.alert_system.get_recent_alerts(severity=severity, alert_type=alert_type, limit=limit)
                pass

            # For now, return mock alerts
            alerts = [
                {
                    "id": "ALERT_001",
                    "timestamp": (datetime.now() - timedelta(minutes=15)).isoformat(),
                    "severity": "high",
                    "type": "price_movement",
                    "status": "active",
                    "title": "Significant Price Movement",
                    "message": "AAPL has moved +5.2% in the last hour",
                    "symbol": "AAPL",
                    "price_change": 0.052
                },
                {
                    "id": "ALERT_002",
                    "timestamp": (datetime.now() - timedelta(hours=1)).isoformat(),
                    "severity": "medium",
                    "type": "volume_spike",
                    "status": "active",
                    "title": "Volume Spike Detected",
                    "message": "TSLA volume is 3x above average",
                    "symbol": "TSLA",
                    "context": {"volume_multiplier": 3.0}
                }
            ]

            return alerts

        except Exception as e:
            logger.error(f"Failed to get alerts: {e}")
            return []

    # Mock data methods (fallback when Tiger API is not available)
    def _get_mock_assets(self, limit: int, offset: int, asset_type: Optional[str]) -> List[Dict]:
        """Mock assets data"""
        assets = []
        symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "NVDA", "META", "NFLX", "AMD", "CRM"]

        for i, symbol in enumerate(symbols[offset:offset+limit]):
            assets.append({
                "symbol": symbol,
                "name": f"{symbol} Inc.",
                "type": "stock",
                "sector": "Technology",
                "price": 150.0 + i * 10,
                "change": 2.5 - i * 0.5,
                "change_percent": (2.5 - i * 0.5) / (150.0 + i * 10) * 100,
                "volume": 1000000 + i * 100000,
                "market_cap": 1000000000000.0,
                "last_update": datetime.now().isoformat()
            })

        return assets

    def _get_mock_positions(self) -> List[Dict]:
        """Mock positions data"""
        return [
            {
                "symbol": "AAPL",
                "quantity": 100,
                "avg_price": 150.0,
                "current_price": 155.0,
                "market_value": 15500.0,
                "unrealized_pnl": 500.0,
                "unrealized_pnl_percent": 3.33,
                "entry_time": (datetime.now() - timedelta(days=5)).isoformat(),
                "last_update": datetime.now().isoformat()
            }
        ]

    def _get_mock_portfolio_summary(self) -> Dict:
        """Mock portfolio summary"""
        return {
            "total_value": 250000.0,
            "total_pnl": 12500.0,
            "total_pnl_percent": 5.26,
            "daily_pnl": 1250.0,
            "daily_pnl_percent": 0.5,
            "positions_count": 5,
            "cash_balance": 50000.0,
            "buying_power": 100000.0,
            "margin_used": 0.0,
            "risk_metrics": {
                "sharpe_ratio": 1.8,
                "max_drawdown": -0.08,
                "portfolio_beta": 1.2,
                "volatility": 0.16
            }
        }

    def _get_mock_orders(self, status: Optional[str], symbol: Optional[str], limit: int) -> List[Dict]:
        """Mock orders data"""
        return [
            {
                "id": "ORDER_001",
                "symbol": "AAPL",
                "side": "buy",
                "type": "market",
                "quantity": 100,
                "price": None,
                "status": "filled",
                "filled_quantity": 100,
                "avg_fill_price": 155.0,
                "created_at": (datetime.now() - timedelta(hours=2)).isoformat(),
                "updated_at": (datetime.now() - timedelta(hours=2)).isoformat()
            }
        ]

    def _create_mock_order(self, order_request: Dict) -> Dict:
        """Mock order creation"""
        return {
            "id": f"ORDER_{int(datetime.now().timestamp())}",
            "symbol": order_request["symbol"],
            "side": order_request["side"],
            "type": order_request["type"],
            "quantity": order_request["quantity"],
            "price": order_request.get("price"),
            "stop_price": order_request.get("stop_price"),
            "status": "pending",
            "filled_quantity": 0,
            "avg_fill_price": None,
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat()
        }

    def _create_mock_order_with_cost_analysis(self, order_request: Dict) -> Dict:
        """Mock order creation with cost analysis"""
        # Generate mock cost analysis
        mock_price = order_request.get("price", 150.0)
        cost_analysis = {
            "total_cost": order_request["quantity"] * mock_price * 0.0012,  # 12 bps for mock
            "cost_basis_points": 12.0,
            "recommended_order_type": "limit" if order_request["type"] == "market" and order_request["quantity"] > 1000 else order_request["type"],
            "market_data": {
                "symbol": order_request["symbol"],
                "price": mock_price,
                "spread": 0.01,
                "volume": 1000000
            },
            "cost_breakdown": {
                "spread_cost": 8.0,
                "market_impact": 3.0,
                "timing_cost": 1.0
            }
        }

        order = self._create_mock_order(order_request)
        order["cost_analysis"] = cost_analysis
        return order

    def _get_mock_market_state(self) -> Dict:
        """Mock market state"""
        return {
            "status": "open",
            "market_trend": 0.02,
            "volatility": 0.18,
            "volume_ratio": 1.1,
            "fear_greed_index": 65,
            "next_open": (datetime.now() + timedelta(hours=16)).isoformat(),
            "regime": "normal",
            "risk_level": "medium"
        }


# Global instance
tiger_provider = TigerDataProvider()